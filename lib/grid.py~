import numpy as np
import matplotlib.pyplot as plt

def naca(x,c,t0):
    """NACA 00XX series equation"""
    import numpy as np
    t=t0*0.01
    k=0.991148635
    xc=x/c
    y= (t*c*k/0.2) \
    * (0.298222773*np.sqrt(xc)-0.127125232*xc-0.357907806*xc**2 \
    +0.291984971*xc**3-0.105174606*xc**4)
    return y
    
def qhermite(x,y0,yx0,y1,yx1,yxx0=0.0,yxx1=0.0):
    """Quintic Hermitiean interpolation"""
    l=len(x)-1; s=np.zeros(l+1);f=np.zeros(l+1)
    x0=x[0];x1=x[l]; dx=x1-x0
    dy=y1-y0
    s[:]=(x[:]-x0)/dx
    p0=y0;p1=yx0*dx;p2=yxx0*dx**2
    p5=y1;p4=yx1*dx;p3=yxx1*dx**2
    p=np.matrix([[p0,p1,p2,p3,p4,p5]])
    if  (yx0==yx1 and y1==(y0+yx0*dx)):
        c=np.matrix([
        [+00.0,-00.0,+00.0,-00.0,-01.0,+01.0],
        [+00.0,-00.0,+00.0,-00.0,+00.0,+00.0],
        [+00.0,-00.0,+00.0,-00.0,+00.0,+00.0],
        [+00.0,-00.0,+00.0,-00.0,+00.0,+00.0],
        [+00.0,-00.0,+00.0,-00.0,+00.0,+00.0],
        [-00.0,+00.0,-00.0,+00.0,+01.0,+00.0]])
    else:
        c=np.matrix([
        [-06.0,+15.0,-10.0,+00.0,+00.0,+01.0],
        [-03.0,+08.0,-06.0,+00.0,+01.0,+00.0],
        [-00.5,+01.5,-01.5,+00.5,+00.0,+00.0],
        [+00.5,-01.0,+00.5,+00.0,+00.0,+00.0],
        [-03.0,+07.0,-04.0,+00.0,+00.0,+00.0],
        [+06.0,-15.0,+10.0,+00.0,+00.0,+00.0]])
                                                
    for i in range(l+1):
        t=np.matrix([
                    [s[i]**5],
                    [s[i]**4],
                    [s[i]**3],
                    [s[i]**2],
                    [s[i]**1],
                    [s[i]**0]
                            ])
        f[i]=(p*c*t)
    return f
    
def qahermite(x,y0,yx0,y1,yx1,side,lnr=0):
    """Quintic Hermitiean interpolation"""
    l=len(x)-1; s=np.zeros(l+1);f=np.zeros(l+1)
    x0=x[0];x1=x[l]; dx=x1-x0
    s[:]=(x[:]-x0)/dx
    p0=y0;p1=yx0*dx
    p3=y1;p2=yx1*dx;
    p=np.matrix([[p0,p1,p2,p3]])
    if (lnr==1):
        c=np.matrix([
        [-00.0,+00.0,-00.0,-01.0,+01.0],
        [-00.0,+00.0,-00.0,+00.0,+00.0],
        [-00.0,+00.0,-00.0,+00.0,+00.0],
        [+00.0,-00.0,+00.0,+01.0,+00.0]])
    else:
        if (side==1):
            c=np.matrix([
            [-03.0,+08.0,-06.0,+00.0,+01.0],
            [-01.0,+03.0,-03.0,+01.0,+00.0],
            [-02.0,+05.0,-03.0,+00.0,+00.0],
            [+03.0,-08.0,+06.0,+00.0,+00.0]])
        else:
            c=np.matrix([
            [+03.0,-04.0,-00.0,-00.0,+01.0],
            [+02.0,-03.0,+00.0,+01.0,+00.0],
            [+01.0,-01.0,+00.0,+00.0,+00.0],
            [-03.0,+04.0,+00.0,+00.0,+00.0]])
    for i in range(l+1):
        t=np.matrix([                                                                                                                                                       
                    [s[i]**4],
                    [s[i]**3],
                    [s[i]**2],
                    [s[i]**1],
                    [s[i]**0]
                            ])
        f[i]=(p*c*t)
    return f
       
def hermite(k1,k2,k3,k4,x0,x1,x):
    """Hermitiean interpolation"""
    l=x1-x0
    invl=1.0/l
    fx=(x-x0)*invl
    a=(2*fx**3-3*fx**2+1)
    b=l*(fx**3-2*fx**2+fx)
    c=(-2*fx**3+3*fx**2)
    d=l*(fx**3-fx**2)
    y=a*k1+b*k2+c*k3+d*k4
    return y

def dfds(f):
    """docstring for drve"""
    import numpy as np
    i0=0; i1=f.shape[0]-1
    fs=np.zeros((i1+1,1))

    for i in range(i0+1,i1):
        fs[i]=0.5*(f[i+1]-f[i-1])
    fs[0]=-1.5*f[0]+2*f[1]-0.5*f[2]; fs[i1]=+1.5*f[i1]-2*f[i1-1]+0.5*f[i1-2]
    return fs
    
def dxi(x,fctr=1):
    n=max(x.shape); l=n-1; dx=np.zeros(n)
    a=np.zeros(n-2);b=np.zeros(n-1);c=np.zeros(n)
    d=np.zeros(n-1);e=np.zeros(n-2);
    a[-1]=1;e[0]=-1
    b[0:-1]=-1;b[-1]=-4;d[1:]=1;d[0]=4;
    c[0]=-3;c[-1]=3
    m=(1/(2*fctr))*np.mat(np.diag(a,-2)+np.diag(b,-1)+np.diag(c,0)+np.diag(d,1)+np.diag(e,2))
    dx=m*np.mat(x).T
    dx=np.asarray(dx.T)[0]
    return dx
    
def makeBndry(lxi=50,let=50):
    """Creates boundaries of a Grid."""
    import numpy as np
    from lib.grid import naca
    from lib.grid import hermite

    x=np.zeros((lxi+1,let+1))
    y=np.zeros((lxi+1,let+1))
    for i in range(0,lxi+1):
        x[i,0]=hermite(0.0,0.5/lxi,1,0.5/lxi,0,lxi,i)
        x[i,let]=hermite(0.0,0.5/lxi,1,0.5/lxi,0,lxi,i)

        y[i,0]=hermite(0.0,0.3,0.0,0.25,0.0,1.0,x[i,let])
        y[i,let]=hermite(1.0,0.2,1.2,-0.6,0.0,1.0,x[i,let])

    for j in range(0,let+1):
        det0=(y[0,let]-y[0,0])/let
        det1=(y[lxi,let]-y[lxi,0])/let
        y[0,j]=hermite(y[0,0],det0,y[0,let],det0,0,let,j)
        y[lxi,j]=hermite(y[lxi,0],det1,y[lxi,let],det1,0,let,j)

        x[0,j]=hermite(x[0,0],-0.5,x[0,let],0.0,y[0,0],y[0,let],y[0,j])
        x[lxi,j]=hermite(x[lxi,0],0.4,x[lxi,let],0.0,y[lxi,0],y[lxi,let],y[lxi,j])
    return x,y

def makeGrid(x,y,opt=0):
    """docstring for makeGridLinear"""
    import numpy as np
    nxi=x.shape[0];net=x.shape[1]
    xis=0;xie=nxi-1;ets=0;ete=net-1
    xf=np.zeros((xie+1,ete+1)); yf=xf.copy()
    xv=np.zeros((xie+1,2))
    xu=np.zeros((ete+1,2))
    xuv=np.zeros((2,2))
    yv=np.zeros((xie+1,2))
    yu=np.zeros((ete+1,2))
    yuv=np.zeros((2,2))


    xv[ 0, 0]=-1.5*x[ 0, 0]+2*x[ 0, 1]-0.5*x[ 0, 2]
    xv[-1, 0]=-1.5*x[-1, 0]+2*x[-1, 1]-0.5*x[-1, 2]
    xv[ 0, 1]=+1.5*x[ 0,-1]-2*x[ 0,-2]+0.5*x[ 0,-3]
    xv[-1, 1]=+1.5*x[-1,-1]-2*x[-1,-2]+0.5*x[-1,-3]

    xu[ 0, 0]=-1.5*x[ 0, 0]+2*x[ 1, 0]-0.5*x[ 2, 0]
    xu[-1, 0]=-1.5*x[ 0,-1]+2*x[ 1,-1]-0.5*x[ 2,-1]
    xu[ 0, 1]=+1.5*x[-1, 0]-2*x[-2, 0]+0.5*x[-3, 0]
    xu[-1, 1]=+1.5*x[-1,-1]-2*x[-2,-1]+0.5*x[-3,-1]

    yv[ 0, 0]=-1.5*y[ 0, 0]+2*y[ 0, 1]-0.5*y[ 0, 2]
    yv[-1, 0]=-1.5*y[-1, 0]+2*y[-1, 1]-0.5*y[-1, 2]
    yv[ 0, 1]=+1.5*y[ 0,-1]-2*y[ 0,-2]+0.5*y[ 0,-3]
    yv[-1, 1]=+1.5*y[-1,-1]-2*y[-1,-2]+0.5*y[-1,-3]

    yu[ 0, 0]=-1.5*y[ 0, 0]+2*y[ 1, 0]-0.5*y[ 2, 0]
    yu[-1, 0]=-1.5*y[ 0,-1]+2*y[ 1,-1]-0.5*y[ 2,-1]
    yu[ 0, 1]=+1.5*y[-1, 0]-2*y[-2, 0]+0.5*y[-3, 0]
    yu[-1, 1]=+1.5*y[-1,-1]-2*y[-2,-1]+0.5*y[-3,-1]

    for i in range(1,4):
        j=i; ii=xie-i; jj=ete-j
        xv[i,0]=hermite(xv[0,0],0,xv[-1,0],0,xis,xie,i)
        xv[i,1]=hermite(xv[0,1],0,xv[-1,1],0,xis,xie,i)
        yv[i,0]=hermite(yv[0,0],0,yv[-1,0],0,xis,xie,i)
        yv[i,1]=hermite(yv[0,1],0,yv[-1,1],0,xis,xie,i)
        xv[ii,0]=hermite(xv[0,0],0,xv[-1,0],0,xis,xie,ii)
        xv[ii,1]=hermite(xv[0,1],0,xv[-1,1],0,xis,xie,ii)
        yv[ii,0]=hermite(yv[0,0],0,yv[-1,0],0,xis,xie,ii)
        yv[ii,1]=hermite(yv[0,1],0,yv[-1,1],0,xis,xie,ii)
        xu[jj,0]=hermite(xu[0,0],0,xu[-1,0],0,ets,ete,jj)
        xu[jj,1]=hermite(xu[0,1],0,xu[-1,1],0,ets,ete,jj)
        yu[jj,0]=hermite(yu[0,0],0,yu[-1,0],0,ets,ete,jj)
        yu[jj,1]=hermite(yu[0,1],0,yu[-1,1],0,ets,ete,jj)

    xuv[ 0, 0]=-1.5*xv[ 0, 0]+2*xv[ 1, 0]-0.5*xv[ 2, 0]
    xuv[ 1, 0]=+1.5*xv[-1, 0]-2*xv[-2, 0]+0.5*xv[-3, 0]
    xuv[ 0, 1]=-1.5*xv[ 0,-1]+2*xv[ 1,-1]-0.5*xv[ 2,-1]
    xuv[ 1, 1]=+1.5*xv[-1,-1]-2*xv[-2,-1]+0.5*xv[-3,-1]

    yuv[ 0, 0]=-1.5*yv[ 0, 0]+2*yv[ 1, 0]-0.5*yv[ 2, 0]
    yuv[ 1, 0]=+1.5*yv[-1, 0]-2*yv[-2, 0]+0.5*yv[-3, 0]
    yuv[ 0, 1]=-1.5*yv[ 0,-1]+2*yv[ 1,-1]-0.5*yv[ 2,-1]
    yuv[ 1, 1]=+1.5*yv[-1,-1]-2*yv[-2,-1]+0.5*yv[-3,-1]

    Mx=np.matrix([
    [x[xis,ets],x[xis,ete],xv[xis,0],xv [xis,1]],
    [x[xie,ets],x[xie,ete],xv[xie,0],xv [xie,1]],
    [xu[ets,0 ],xu[ete,0 ],xuv[0 ,0],xuv[0  ,1]],
    [xu[ets,1 ],xu[ete,1 ],xuv[1 ,0],xuv[1  ,1]]])

    My=np.matrix([
    [y[xis,ets],y[xis,ete],yv[xis,0],yv [xis,1]],
    [y[xie,ets],y[xie,ete],yv[xie,0],yv [xie,1]],
    [yu[ets,0 ],yu[ete,0 ],yuv[0 ,0],yuv[0  ,1]],
    [yu[ets,1 ],yu[ete,1 ],yuv[1 ,0],yuv[1  ,1]]])

    if  opt==0:
        a0 = lambda u: 2*u**3-3*u**2+1
        a1 = lambda u: 3*u**2-2*u**3
        b0 = lambda u: u**3-2*u**2+u
        b1 = lambda u: u**3-u**2
    elif  opt==1:
        a0 = lambda u: (1-u)
        a1 = lambda u: u
        b0 = lambda u: 0.0
        b1 = lambda u: 0.0

    for j in range(0,net):
        v=(j-ets)/(ete-ets)
        abv=np.matrix([[a0(v),a1(v),b0(v),b1(v)]])
        Xv=np.matrix([[x [xis, j ]],
                      [x [xie, j ]],
                      [xu[ j , 0 ]],
                      [xu[ j , 1 ]]])
        Yv=np.matrix([[y [xis, j ]],
                      [y [xie, j ]],
                      [yu[ j , 0 ]],
                      [yu[ j , 1 ]]])
        abvt=abv.T
        for i in range(0,nxi):
            u=(i-xis)/(xie-xis)
            abu=np.matrix([[a0(u),a1(u),b0(u),b1(u)]])
            Xu=np.matrix([[x [ i ,ets]],
                          [x [ i ,ete]],
                          [xv[ i , 0 ]],
                          [xv[ i , 1 ]]])
            Yu=np.matrix([[y [ i ,ets]],
                          [y [ i ,ete]],
                          [yv[ i , 0 ]],
                          [yv[ i , 1 ]]])


            xf[i,j]=abu*Xv+abv*Xu-(abu*Mx*abvt)
            yf[i,j]=abu*Yv+abv*Yu-(abu*My*abvt)

    return xf,yf

def plotgrid(x,y,drw=1,shw=1,stl='b'):
    """docstring for plotgrid"""
    import matplotlib.pyplot as plt
    nxi=x.shape[0];net=x.shape[1]
    xis=0;xie=nxi-1;ets=0;ete=net-1
    #plt.figure(figsize=(10,8))
    #plt.plot(x[:,ets],y[:,ets],'ro',markersize=4)
    #plt.plot(x[:,ete],y[:,ete],'ro',markersize=4)
    #plt.plot(x[xis,:],y[xis,:],'ro',markersize=4)
    #plt.plot(x[xie,:],y[xie,:],'ro',markersize=4)
    for j in range(0,net):
        plt.plot(x[:,j],y[:,j],stl)
    for i in range(0,nxi):
        plt.plot(x[i,:],y[i,:],stl)

    if drw==1:
       plt.draw()
    if shw==1:
       plt.show()
    pass

class corner():
    def __init__(self,x=0.0,y=0.0,
                 dydx=0.0,dxdxi=0.0,d2xdxi2=0.0,
                 dxdy=0.0,dydet=0.0,d2ydet2=0.0):
        self.x=x
        self.y=y

class line():
    def __init__(self,n,c0,c1,dr):
        self.n=n
        self.c0=c0
        self.c1=c1
        self.dr=dr
        if (self.dr==0):
            self.c0.dydx=(self.c1.y-self.c0.y)/(self.c1.x-self.c0.x)
            self.c0.dxdxi=(self.c1.x-self.c0.x)/(n-1)
            self.c0.d2xdxi2=0.0
            self.c1.dydx=self.c0.dydx
            self.c1.dxdxi=self.c0.dxdxi
            self.c1.d2xdxi2=self.c0.d2xdxi2
        if (self.dr==1):
            self.c0.dxdy=(self.c1.x-self.c0.x)/(self.c1.y-self.c0.y)
            self.c0.dydet=(self.c1.y-self.c0.y)/(n-1)
            self.c0.d2ydet2=0.0
            self.c1.dxdy=self.c0.dxdy
            self.c1.dydet=self.c0.dydet
            self.c1.d2ydet2=self.c0.d2ydet2
        self.getPoints()

    def getPoints(self,plot=False):
        if (self.dr==0):
            self.x=qhermite(np.arange(self.n),
                            self.c0.x,self.c0.dxdxi,
                            self.c1.x,self.c1.dxdxi,
                            self.c0.d2xdxi2,self.c1.d2xdxi2)
            self.dxdxi=dxi(self.x)
            self.d2xdxi2=dxi(self.dxdxi)
            self.y=qhermite(self.x,
                            self.c0.y,self.c0.dydx,
                            self.c1.y,self.c1.dydx)
            self.dydxi=dxi(self.y)
            self.d2ydxi2=dxi(self.dydxi)
        if (self.dr==1):
            self.y=qhermite(np.arange(self.n),
                            self.c0.y,self.c0.dydet,
                            self.c1.y,self.c1.dydet,
                            self.c0.d2ydet2,self.c1.d2ydet2)
            self.dydet=dxi(self.y)
            self.d2ydet2=dxi(self.dydet)
            self.x=qhermite(self.y,
                            self.c0.x,self.c0.dxdy,
                            self.c1.x,self.c1.dxdy)
            self.dxdet=dxi(self.x)
            self.d2xdet2=dxi(self.dxdet)
        if (plot==True):
            self.plot()

    def plot(self):
        plt.subplot(411)
        plt.plot(self.x,self.y)
        if (self.dr==0):
            plt.subplot(412)
            plt.plot(self.x)
            plt.subplot(413)
            plt.plot(self.dxdxi)
            plt.subplot(414)
            plt.plot(self.d2xdxi2)
            plt.show()
        if (self.dr==1):
            plt.subplot(412)
            plt.plot(self.y)
            plt.subplot(413)
            plt.plot(self.dydet)
            plt.subplot(414)
            plt.plot(self.d2ydet2)
            plt.show()
    def draw(self,show=False):
        plt.plot(self.x,self.y,'b')
        plt.plot(self.x,self.y,'ro')
        plt.draw()
        if (show==True):
           plt.show()

class block():
    def __init__(self,bs,bn,bw,be):
        self.bs=bs
        self.bn=bn
        self.bw=bw
        self.be=be
        self.lxi=bs.n
        self.let=bw.n

        self.bs.dxdet=qhermite(np.arange(self.lxi),
                               self.bw.dydet[0],0.0,
                               self.be.dydet[0],0.0)
        self.bn.dxdet=qhermite(np.arange(self.lxi),
                               self.bw.dydet[-1],0.0,
                               self.be.dydet[-1],0.0)
        self.bw.dydxi=qhermite(np.arange(self.let),
                               self.bs.dxdxi[0],0.0,
                               self.bn.dxdxi[0],0.0)
        self.be.dydxi=qhermite(np.arange(self.let),
                               self.bs.dxdxi[-1],0.0,
                               self.bn.dxdxi[-1],0.0)


        



















